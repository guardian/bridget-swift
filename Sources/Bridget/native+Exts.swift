/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: Rect, rhs: Rect) -> Bool {
  return
    (lhs.x == rhs.x) &&
    (lhs.y == rhs.y) &&
    (lhs.height == rhs.height) &&
    (lhs.width == rhs.width)
}

extension Rect : CustomStringConvertible {

  public var description : String {
    var desc = "Rect("
    desc += "x=\(String(describing: self.x)), "
    desc += "y=\(String(describing: self.y)), "
    desc += "height=\(String(describing: self.height)), "
    desc += "width=\(String(describing: self.width))"
    return desc
  }

}

extension Rect : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(x)
    hasher.combine(y)
    hasher.combine(height)
    hasher.combine(width)
  }

}

extension Rect : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["x": 1, "y": 2, "height": 3, "width": 4, ]
  }

  public static var structName: String { return "Rect" }

  public static func read(from proto: TProtocol) throws -> Rect {
    _ = try proto.readStructBegin()
    var x: Double!
    var y: Double!
    var height: Double!
    var width: Double!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .double):           x = try Double.read(from: proto)
        case (2, .double):           y = try Double.read(from: proto)
        case (3, .double):           height = try Double.read(from: proto)
        case (4, .double):           width = try Double.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(x, named: "x")
    try proto.validateValue(y, named: "y")
    try proto.validateValue(height, named: "height")
    try proto.validateValue(width, named: "width")

    return Rect(x: x, y: y, height: height, width: width)
  }

}



public func ==(lhs: AdSlot, rhs: AdSlot) -> Bool {
  return
    (lhs.rect == rhs.rect) &&
    (lhs.targetingParams == rhs.targetingParams) &&
    (lhs.isSquare == rhs.isSquare)
}

extension AdSlot : CustomStringConvertible {

  public var description : String {
    var desc = "AdSlot("
    desc += "rect=\(String(describing: self.rect)), "
    desc += "targetingParams=\(String(describing: self.targetingParams)), "
    desc += "isSquare=\(String(describing: self.isSquare))"
    return desc
  }

}

extension AdSlot : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(rect)
    hasher.combine(targetingParams)
    hasher.combine(isSquare)
  }

}

extension AdSlot : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["rect": 1, "targetingParams": 2, "isSquare": 3, ]
  }

  public static var structName: String { return "AdSlot" }

  public static func read(from proto: TProtocol) throws -> AdSlot {
    _ = try proto.readStructBegin()
    var rect: Rect!
    var targetingParams: TMap<String, String>?
    var isSquare: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           rect = try Rect.read(from: proto)
        case (2, .map):             targetingParams = try TMap<String, String>.read(from: proto)
        case (3, .bool):            isSquare = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(rect, named: "rect")
    try proto.validateValue(isSquare, named: "isSquare")

    return AdSlot(rect: rect, targetingParams: targetingParams, isSquare: isSquare)
  }

}



public func ==(lhs: Topic, rhs: Topic) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.displayName == rhs.displayName) &&
    (lhs.type == rhs.type)
}

extension Topic : CustomStringConvertible {

  public var description : String {
    var desc = "Topic("
    desc += "id=\(String(describing: self.id)), "
    desc += "displayName=\(String(describing: self.displayName)), "
    desc += "type=\(String(describing: self.type))"
    return desc
  }

}

extension Topic : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
    hasher.combine(displayName)
    hasher.combine(type)
  }

}

extension Topic : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "displayName": 2, "type": 3, ]
  }

  public static var structName: String { return "Topic" }

  public static func read(from proto: TProtocol) throws -> Topic {
    _ = try proto.readStructBegin()
    var id: String!
    var displayName: String!
    var type: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .string):           displayName = try String.read(from: proto)
        case (3, .string):           type = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(displayName, named: "displayName")
    try proto.validateValue(type, named: "type")

    return Topic(id: id, displayName: displayName, type: type)
  }

}



public func ==(lhs: Image, rhs: Image) -> Bool {
  return
    (lhs.url == rhs.url) &&
    (lhs.width == rhs.width) &&
    (lhs.height == rhs.height) &&
    (lhs.caption == rhs.caption) &&
    (lhs.credit == rhs.credit)
}

extension Image : CustomStringConvertible {

  public var description : String {
    var desc = "Image("
    desc += "url=\(String(describing: self.url)), "
    desc += "width=\(String(describing: self.width)), "
    desc += "height=\(String(describing: self.height)), "
    desc += "caption=\(String(describing: self.caption)), "
    desc += "credit=\(String(describing: self.credit))"
    return desc
  }

}

extension Image : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(url)
    hasher.combine(width)
    hasher.combine(height)
    hasher.combine(caption)
    hasher.combine(credit)
  }

}

extension Image : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["url": 1, "width": 2, "height": 3, "caption": 4, "credit": 5, ]
  }

  public static var structName: String { return "Image" }

  public static func read(from proto: TProtocol) throws -> Image {
    _ = try proto.readStructBegin()
    var url: String!
    var width: Double!
    var height: Double!
    var caption: String?
    var credit: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           url = try String.read(from: proto)
        case (2, .double):           width = try Double.read(from: proto)
        case (3, .double):           height = try Double.read(from: proto)
        case (4, .string):           caption = try String.read(from: proto)
        case (5, .string):           credit = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(url, named: "url")
    try proto.validateValue(width, named: "width")
    try proto.validateValue(height, named: "height")

    return Image(url: url, width: width, height: height, caption: caption, credit: credit)
  }

}



public func ==(lhs: Epic, rhs: Epic) -> Bool {
  return
    (lhs.title == rhs.title) &&
    (lhs.body == rhs.body) &&
    (lhs.firstButton == rhs.firstButton) &&
    (lhs.secondButton == rhs.secondButton)
}

extension Epic : CustomStringConvertible {

  public var description : String {
    var desc = "Epic("
    desc += "title=\(String(describing: self.title)), "
    desc += "body=\(String(describing: self.body)), "
    desc += "firstButton=\(String(describing: self.firstButton)), "
    desc += "secondButton=\(String(describing: self.secondButton))"
    return desc
  }

}

extension Epic : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(title)
    hasher.combine(body)
    hasher.combine(firstButton)
    hasher.combine(secondButton)
  }

}

extension Epic : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["title": 1, "body": 2, "firstButton": 3, "secondButton": 4, ]
  }

  public static var structName: String { return "Epic" }

  public static func read(from proto: TProtocol) throws -> Epic {
    _ = try proto.readStructBegin()
    var title: String!
    var body: String!
    var firstButton: String!
    var secondButton: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           title = try String.read(from: proto)
        case (2, .string):           body = try String.read(from: proto)
        case (3, .string):           firstButton = try String.read(from: proto)
        case (4, .string):           secondButton = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(title, named: "title")
    try proto.validateValue(body, named: "body")
    try proto.validateValue(firstButton, named: "firstButton")

    return Epic(title: title, body: body, firstButton: firstButton, secondButton: secondButton)
  }

}



public func ==(lhs: MaybeEpic, rhs: MaybeEpic) -> Bool {
  return
    (lhs.epic == rhs.epic)
}

extension MaybeEpic : CustomStringConvertible {

  public var description : String {
    var desc = "MaybeEpic("
    desc += "epic=\(String(describing: self.epic))"
    return desc
  }

}

extension MaybeEpic : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(epic)
  }

}

extension MaybeEpic : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["epic": 1, ]
  }

  public static var structName: String { return "MaybeEpic" }

  public static func read(from proto: TProtocol) throws -> MaybeEpic {
    _ = try proto.readStructBegin()
    var epic: Epic?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           epic = try Epic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return MaybeEpic(epic: epic)
  }

}



public func ==(lhs: VideoSlot, rhs: VideoSlot) -> Bool {
  return
    (lhs.rect == rhs.rect) &&
    (lhs.videoId == rhs.videoId) &&
    (lhs.posterUrl == rhs.posterUrl) &&
    (lhs.duration == rhs.duration)
}

extension VideoSlot : CustomStringConvertible {

  public var description : String {
    var desc = "VideoSlot("
    desc += "rect=\(String(describing: self.rect)), "
    desc += "videoId=\(String(describing: self.videoId)), "
    desc += "posterUrl=\(String(describing: self.posterUrl)), "
    desc += "duration=\(String(describing: self.duration))"
    return desc
  }

}

extension VideoSlot : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(rect)
    hasher.combine(videoId)
    hasher.combine(posterUrl)
    hasher.combine(duration)
  }

}

extension VideoSlot : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["rect": 1, "videoId": 2, "posterUrl": 3, "duration": 4, ]
  }

  public static var structName: String { return "VideoSlot" }

  public static func read(from proto: TProtocol) throws -> VideoSlot {
    _ = try proto.readStructBegin()
    var rect: Rect!
    var videoId: String!
    var posterUrl: String!
    var duration: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           rect = try Rect.read(from: proto)
        case (2, .string):           videoId = try String.read(from: proto)
        case (3, .string):           posterUrl = try String.read(from: proto)
        case (4, .i32):             duration = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(rect, named: "rect")
    try proto.validateValue(videoId, named: "videoId")
    try proto.validateValue(posterUrl, named: "posterUrl")

    return VideoSlot(rect: rect, videoId: videoId, posterUrl: posterUrl, duration: duration)
  }

}



public func ==(lhs: MetricPaint, rhs: MetricPaint) -> Bool {
  return
    (lhs.time == rhs.time)
}

extension MetricPaint : CustomStringConvertible {

  public var description : String {
    var desc = "MetricPaint("
    desc += "time=\(String(describing: self.time))"
    return desc
  }

}

extension MetricPaint : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(time)
  }

}

extension MetricPaint : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["time": 1, ]
  }

  public static var structName: String { return "MetricPaint" }

  public static func read(from proto: TProtocol) throws -> MetricPaint {
    _ = try proto.readStructBegin()
    var time: Double!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .double):           time = try Double.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(time, named: "time")

    return MetricPaint(time: time)
  }

}



public func ==(lhs: MetricFont, rhs: MetricFont) -> Bool {
  return
    (lhs.duration == rhs.duration) &&
    (lhs.size == rhs.size) &&
    (lhs.name == rhs.name)
}

extension MetricFont : CustomStringConvertible {

  public var description : String {
    var desc = "MetricFont("
    desc += "duration=\(String(describing: self.duration)), "
    desc += "size=\(String(describing: self.size)), "
    desc += "name=\(String(describing: self.name))"
    return desc
  }

}

extension MetricFont : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(duration)
    hasher.combine(size)
    hasher.combine(name)
  }

}

extension MetricFont : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["duration": 1, "size": 2, "name": 3, ]
  }

  public static var structName: String { return "MetricFont" }

  public static func read(from proto: TProtocol) throws -> MetricFont {
    _ = try proto.readStructBegin()
    var duration: Double!
    var size: Int32?
    var name: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .double):           duration = try Double.read(from: proto)
        case (2, .i32):             size = try Int32.read(from: proto)
        case (3, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(duration, named: "duration")

    return MetricFont(duration: duration, size: size, name: name)
  }

}



public func ==(lhs: Metric, rhs: Metric) -> Bool {
  return {
    switch (lhs, rhs) {
    case (.firstPaint(let lval), .firstPaint(let rval)): return lval == rval
    case (.firstContentfulPaint(let lval), .firstContentfulPaint(let rval)): return lval == rval
    case (.font(let lval), .font(let rval)): return lval == rval
    default: return false
    }
  }()
}

extension Metric : CustomStringConvertible {

  public var description : String {
    var desc = "Metric."
    switch self {
    case .firstPaint(let val): desc += "firstPaint(val: \(val))"
    case .firstContentfulPaint(let val): desc += "firstContentfulPaint(val: \(val))"
    case .font(let val): desc += "font(val: \(val))"
    }
    return desc
  }

}

extension Metric : Hashable {

  public func hash(into hasher: inout Hasher) {
    switch self {
    case .firstPaint(let val): hasher.combine(val)
    case .firstContentfulPaint(let val): hasher.combine(val)
    case .font(let val): hasher.combine(val)
    }

  }

}

extension Metric : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["firstPaint": 1, "firstContentfulPaint": 2, "font": 3, ]
  }

  public static var structName: String { return "Metric" }

  public static func read(from proto: TProtocol) throws -> Metric {
    _ = try proto.readStructBegin()
    var ret: Metric?
    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):                   ret = Metric.firstPaint(val: try MetricPaint.read(from: proto))
        case (2, .struct):                   ret = Metric.firstContentfulPaint(val: try MetricPaint.read(from: proto))
        case (3, .struct):                   ret = Metric.font(val: try MetricFont.read(from: proto))
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }
      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    if let ret = ret {
      return ret
    }

    throw TProtocolError(error: .unknown, message: "Missing required value for type: Metric")  }

}



public func ==(lhs: VideoEvent, rhs: VideoEvent) -> Bool {
  return
    (lhs.videoId == rhs.videoId) &&
    (lhs.event == rhs.event)
}

extension VideoEvent : CustomStringConvertible {

  public var description : String {
    var desc = "VideoEvent("
    desc += "videoId=\(String(describing: self.videoId)), "
    desc += "event=\(String(describing: self.event))"
    return desc
  }

}

extension VideoEvent : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(videoId)
    hasher.combine(event)
  }

}

extension VideoEvent : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["videoId": 1, "event": 2, ]
  }

  public static var structName: String { return "VideoEvent" }

  public static func read(from proto: TProtocol) throws -> VideoEvent {
    _ = try proto.readStructBegin()
    var videoId: String!
    var event: MediaEvent!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           videoId = try String.read(from: proto)
        case (2, .i32):             event = try MediaEvent.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(videoId, named: "videoId")
    try proto.validateValue(event, named: "event")

    return VideoEvent(videoId: videoId, event: event)
  }

}



public func ==(lhs: DiscussionServiceResponse, rhs: DiscussionServiceResponse) -> Bool {
  return {
    switch (lhs, rhs) {
    case (.response(let lval), .response(let rval)): return lval == rval
    case (.error(let lval), .error(let rval)): return lval == rval
    default: return false
    }
  }()
}

extension DiscussionServiceResponse : CustomStringConvertible {

  public var description : String {
    var desc = "DiscussionServiceResponse."
    switch self {
    case .response(let val): desc += "response(val: \(val))"
    case .error(let val): desc += "error(val: \(val))"
    }
    return desc
  }

}

extension DiscussionServiceResponse : Hashable {

  public func hash(into hasher: inout Hasher) {
    switch self {
    case .response(let val): hasher.combine(val)
    case .error(let val): hasher.combine(val)
    }

  }

}

extension DiscussionServiceResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["response": 1, "error": 2, ]
  }

  public static var structName: String { return "DiscussionServiceResponse" }

  public static func read(from proto: TProtocol) throws -> DiscussionServiceResponse {
    _ = try proto.readStructBegin()
    var ret: DiscussionServiceResponse?
    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):                   ret = DiscussionServiceResponse.response(val: try String.read(from: proto))
        case (2, .i32):                     ret = DiscussionServiceResponse.error(val: try DiscussionNativeError.read(from: proto))
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }
      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    if let ret = ret {
      return ret
    }

    throw TProtocolError(error: .unknown, message: "Missing required value for type: DiscussionServiceResponse")  }

}



fileprivate final class Environment_nativeThriftPackageVersion_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Environment_nativeThriftPackageVersion_args, rhs: Environment_nativeThriftPackageVersion_args) -> Bool {
  return true
}

extension Environment_nativeThriftPackageVersion_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Environment_nativeThriftPackageVersion_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Environment_nativeThriftPackageVersion_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Environment_nativeThriftPackageVersion_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Environment_nativeThriftPackageVersion_args()
  }

}



fileprivate final class Environment_nativeThriftPackageVersion_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Environment_nativeThriftPackageVersion_result, rhs: Environment_nativeThriftPackageVersion_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Environment_nativeThriftPackageVersion_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Environment_nativeThriftPackageVersion_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Environment_nativeThriftPackageVersion_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Environment_nativeThriftPackageVersion_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Environment_nativeThriftPackageVersion_result(success: success)
  }

}



fileprivate final class Environment_isMyGuardianEnabled_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Environment_isMyGuardianEnabled_args, rhs: Environment_isMyGuardianEnabled_args) -> Bool {
  return true
}

extension Environment_isMyGuardianEnabled_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Environment_isMyGuardianEnabled_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Environment_isMyGuardianEnabled_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Environment_isMyGuardianEnabled_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Environment_isMyGuardianEnabled_args()
  }

}



fileprivate final class Environment_isMyGuardianEnabled_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Environment_isMyGuardianEnabled_result, rhs: Environment_isMyGuardianEnabled_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Environment_isMyGuardianEnabled_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Environment_isMyGuardianEnabled_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Environment_isMyGuardianEnabled_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Environment_isMyGuardianEnabled_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Environment_isMyGuardianEnabled_result(success: success)
  }

}



extension EnvironmentClient : Environment {

  private func send_nativeThriftPackageVersion() throws {
    try outProtocol.writeMessageBegin(name: "nativeThriftPackageVersion", type: .call, sequenceID: 0)
    let args = Environment_nativeThriftPackageVersion_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_nativeThriftPackageVersion() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try Environment_nativeThriftPackageVersion_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "nativeThriftPackageVersion"))
  }

  public func nativeThriftPackageVersion() throws -> String {
    try send_nativeThriftPackageVersion()
    try outProtocol.transport.flush()
    return try recv_nativeThriftPackageVersion()
  }

  private func send_isMyGuardianEnabled() throws {
    try outProtocol.writeMessageBegin(name: "isMyGuardianEnabled", type: .call, sequenceID: 0)
    let args = Environment_isMyGuardianEnabled_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isMyGuardianEnabled() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Environment_isMyGuardianEnabled_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "isMyGuardianEnabled"))
  }

  public func isMyGuardianEnabled() throws -> Bool {
    try send_isMyGuardianEnabled()
    try outProtocol.transport.flush()
    return try recv_isMyGuardianEnabled()
  }

}

extension EnvironmentProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["nativeThriftPackageVersion"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Environment_nativeThriftPackageVersion_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Environment_nativeThriftPackageVersion_result()
      do {
        result.success = try handler.nativeThriftPackageVersion()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "nativeThriftPackageVersion", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["isMyGuardianEnabled"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Environment_isMyGuardianEnabled_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Environment_isMyGuardianEnabled_result()
      do {
        result.success = try handler.isMyGuardianEnabled()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isMyGuardianEnabled", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = EnvironmentProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension EnvironmentProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["nativeThriftPackageVersion"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Environment_nativeThriftPackageVersion_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.nativeThriftPackageVersion(completion: { asyncResult in
        var result = Environment_nativeThriftPackageVersion_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "nativeThriftPackageVersion", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "nativeThriftPackageVersion", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "nativeThriftPackageVersion", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["isMyGuardianEnabled"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Environment_isMyGuardianEnabled_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.isMyGuardianEnabled(completion: { asyncResult in
        var result = Environment_isMyGuardianEnabled_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "isMyGuardianEnabled", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "isMyGuardianEnabled", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "isMyGuardianEnabled", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = EnvironmentProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Commercial_insertAdverts_args {

  fileprivate var adSlots: TList<AdSlot>


  fileprivate init(adSlots: TList<AdSlot>) {
    self.adSlots = adSlots
  }

}

fileprivate func ==(lhs: Commercial_insertAdverts_args, rhs: Commercial_insertAdverts_args) -> Bool {
  return
    (lhs.adSlots == rhs.adSlots)
}

extension Commercial_insertAdverts_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(adSlots)
  }

}

extension Commercial_insertAdverts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["adSlots": 1, ]
  }

  fileprivate static var structName: String { return "Commercial_insertAdverts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_insertAdverts_args {
    _ = try proto.readStructBegin()
    var adSlots: TList<AdSlot>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            adSlots = try TList<AdSlot>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(adSlots, named: "adSlots")

    return Commercial_insertAdverts_args(adSlots: adSlots)
  }

}



fileprivate final class Commercial_insertAdverts_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Commercial_insertAdverts_result, rhs: Commercial_insertAdverts_result) -> Bool {
  return true
}

extension Commercial_insertAdverts_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Commercial_insertAdverts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Commercial_insertAdverts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_insertAdverts_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Commercial_insertAdverts_result()
  }

}



fileprivate final class Commercial_updateAdverts_args {

  fileprivate var adSlots: TList<AdSlot>


  fileprivate init(adSlots: TList<AdSlot>) {
    self.adSlots = adSlots
  }

}

fileprivate func ==(lhs: Commercial_updateAdverts_args, rhs: Commercial_updateAdverts_args) -> Bool {
  return
    (lhs.adSlots == rhs.adSlots)
}

extension Commercial_updateAdverts_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(adSlots)
  }

}

extension Commercial_updateAdverts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["adSlots": 1, ]
  }

  fileprivate static var structName: String { return "Commercial_updateAdverts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_updateAdverts_args {
    _ = try proto.readStructBegin()
    var adSlots: TList<AdSlot>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            adSlots = try TList<AdSlot>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(adSlots, named: "adSlots")

    return Commercial_updateAdverts_args(adSlots: adSlots)
  }

}



fileprivate final class Commercial_updateAdverts_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Commercial_updateAdverts_result, rhs: Commercial_updateAdverts_result) -> Bool {
  return true
}

extension Commercial_updateAdverts_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Commercial_updateAdverts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Commercial_updateAdverts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_updateAdverts_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Commercial_updateAdverts_result()
  }

}



extension CommercialClient : Commercial {

  private func send_insertAdverts(adSlots: TList<AdSlot>) throws {
    try outProtocol.writeMessageBegin(name: "insertAdverts", type: .call, sequenceID: 0)
    let args = Commercial_insertAdverts_args(adSlots: adSlots)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_insertAdverts() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Commercial_insertAdverts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func insertAdverts(adSlots: TList<AdSlot>) throws {
    try send_insertAdverts(adSlots: adSlots)
    try outProtocol.transport.flush()
    try recv_insertAdverts()
  }

  private func send_updateAdverts(adSlots: TList<AdSlot>) throws {
    try outProtocol.writeMessageBegin(name: "updateAdverts", type: .call, sequenceID: 0)
    let args = Commercial_updateAdverts_args(adSlots: adSlots)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateAdverts() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Commercial_updateAdverts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func updateAdverts(adSlots: TList<AdSlot>) throws {
    try send_updateAdverts(adSlots: adSlots)
    try outProtocol.transport.flush()
    try recv_updateAdverts()
  }

}

extension CommercialProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["insertAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_insertAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Commercial_insertAdverts_result()
      do {
        try handler.insertAdverts(adSlots: args.adSlots)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "insertAdverts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["updateAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_updateAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Commercial_updateAdverts_result()
      do {
        try handler.updateAdverts(adSlots: args.adSlots)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateAdverts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = CommercialProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension CommercialProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["insertAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_insertAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.insertAdverts(adSlots: args.adSlots, completion: { asyncResult in
        var result = Commercial_insertAdverts_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "insertAdverts", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "insertAdverts", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "insertAdverts", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["updateAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_updateAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.updateAdverts(adSlots: args.adSlots, completion: { asyncResult in
        var result = Commercial_updateAdverts_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "updateAdverts", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "updateAdverts", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "updateAdverts", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = CommercialProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Acquisitions_launchPurchaseScreen_args {

  fileprivate var reason: PurchaseScreenReason


  fileprivate init(reason: PurchaseScreenReason) {
    self.reason = reason
  }

}

fileprivate func ==(lhs: Acquisitions_launchPurchaseScreen_args, rhs: Acquisitions_launchPurchaseScreen_args) -> Bool {
  return
    (lhs.reason == rhs.reason)
}

extension Acquisitions_launchPurchaseScreen_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(reason)
  }

}

extension Acquisitions_launchPurchaseScreen_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reason": 1, ]
  }

  fileprivate static var structName: String { return "Acquisitions_launchPurchaseScreen_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquisitions_launchPurchaseScreen_args {
    _ = try proto.readStructBegin()
    var reason: PurchaseScreenReason!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reason = try PurchaseScreenReason.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reason, named: "reason")

    return Acquisitions_launchPurchaseScreen_args(reason: reason)
  }

}



fileprivate final class Acquisitions_launchPurchaseScreen_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquisitions_launchPurchaseScreen_result, rhs: Acquisitions_launchPurchaseScreen_result) -> Bool {
  return true
}

extension Acquisitions_launchPurchaseScreen_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquisitions_launchPurchaseScreen_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquisitions_launchPurchaseScreen_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquisitions_launchPurchaseScreen_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquisitions_launchPurchaseScreen_result()
  }

}



fileprivate final class Acquisitions_getEpics_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquisitions_getEpics_args, rhs: Acquisitions_getEpics_args) -> Bool {
  return true
}

extension Acquisitions_getEpics_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquisitions_getEpics_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquisitions_getEpics_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquisitions_getEpics_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquisitions_getEpics_args()
  }

}



fileprivate final class Acquisitions_getEpics_result {

  fileprivate var success: MaybeEpic?


  fileprivate init() { }
  fileprivate init(success: MaybeEpic?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Acquisitions_getEpics_result, rhs: Acquisitions_getEpics_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Acquisitions_getEpics_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Acquisitions_getEpics_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Acquisitions_getEpics_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquisitions_getEpics_result {
    _ = try proto.readStructBegin()
    var success: MaybeEpic?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try MaybeEpic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquisitions_getEpics_result(success: success)
  }

}



fileprivate final class Acquisitions_epicSeen_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquisitions_epicSeen_args, rhs: Acquisitions_epicSeen_args) -> Bool {
  return true
}

extension Acquisitions_epicSeen_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquisitions_epicSeen_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquisitions_epicSeen_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquisitions_epicSeen_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquisitions_epicSeen_args()
  }

}



fileprivate final class Acquisitions_epicSeen_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquisitions_epicSeen_result, rhs: Acquisitions_epicSeen_result) -> Bool {
  return true
}

extension Acquisitions_epicSeen_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquisitions_epicSeen_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquisitions_epicSeen_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquisitions_epicSeen_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquisitions_epicSeen_result()
  }

}



extension AcquisitionsClient : Acquisitions {

  private func send_launchPurchaseScreen(reason: PurchaseScreenReason) throws {
    try outProtocol.writeMessageBegin(name: "launchPurchaseScreen", type: .call, sequenceID: 0)
    let args = Acquisitions_launchPurchaseScreen_args(reason: reason)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_launchPurchaseScreen() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Acquisitions_launchPurchaseScreen_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func launchPurchaseScreen(reason: PurchaseScreenReason) throws {
    try send_launchPurchaseScreen(reason: reason)
    try outProtocol.transport.flush()
    try recv_launchPurchaseScreen()
  }

  private func send_getEpics() throws {
    try outProtocol.writeMessageBegin(name: "getEpics", type: .call, sequenceID: 0)
    let args = Acquisitions_getEpics_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getEpics() throws -> MaybeEpic {
    try inProtocol.readResultMessageBegin() 
    let result = try Acquisitions_getEpics_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "getEpics"))
  }

  public func getEpics() throws -> MaybeEpic {
    try send_getEpics()
    try outProtocol.transport.flush()
    return try recv_getEpics()
  }

  private func send_epicSeen() throws {
    try outProtocol.writeMessageBegin(name: "epicSeen", type: .call, sequenceID: 0)
    let args = Acquisitions_epicSeen_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_epicSeen() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Acquisitions_epicSeen_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func epicSeen() throws {
    try send_epicSeen()
    try outProtocol.transport.flush()
    try recv_epicSeen()
  }

}

extension AcquisitionsProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchPurchaseScreen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquisitions_launchPurchaseScreen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Acquisitions_launchPurchaseScreen_result()
      do {
        try handler.launchPurchaseScreen(reason: args.reason)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "launchPurchaseScreen", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["getEpics"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquisitions_getEpics_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Acquisitions_getEpics_result()
      do {
        result.success = try handler.getEpics()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getEpics", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["epicSeen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquisitions_epicSeen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Acquisitions_epicSeen_result()
      do {
        try handler.epicSeen()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "epicSeen", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AcquisitionsProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension AcquisitionsProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchPurchaseScreen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquisitions_launchPurchaseScreen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.launchPurchaseScreen(reason: args.reason, completion: { asyncResult in
        var result = Acquisitions_launchPurchaseScreen_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "launchPurchaseScreen", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "launchPurchaseScreen", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "launchPurchaseScreen", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["getEpics"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquisitions_getEpics_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.getEpics(completion: { asyncResult in
        var result = Acquisitions_getEpics_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "getEpics", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "getEpics", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "getEpics", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["epicSeen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquisitions_epicSeen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.epicSeen(completion: { asyncResult in
        var result = Acquisitions_epicSeen_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "epicSeen", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "epicSeen", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "epicSeen", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AcquisitionsProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Tag_follow_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Tag_follow_args, rhs: Tag_follow_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Tag_follow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Tag_follow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Tag_follow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Tag_follow_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Tag_follow_args(topic: topic)
  }

}



fileprivate final class Tag_follow_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Tag_follow_result, rhs: Tag_follow_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Tag_follow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Tag_follow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Tag_follow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Tag_follow_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Tag_follow_result(success: success)
  }

}



fileprivate final class Tag_unfollow_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Tag_unfollow_args, rhs: Tag_unfollow_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Tag_unfollow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Tag_unfollow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Tag_unfollow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Tag_unfollow_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Tag_unfollow_args(topic: topic)
  }

}



fileprivate final class Tag_unfollow_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Tag_unfollow_result, rhs: Tag_unfollow_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Tag_unfollow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Tag_unfollow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Tag_unfollow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Tag_unfollow_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Tag_unfollow_result(success: success)
  }

}



fileprivate final class Tag_isFollowing_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Tag_isFollowing_args, rhs: Tag_isFollowing_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Tag_isFollowing_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Tag_isFollowing_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Tag_isFollowing_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Tag_isFollowing_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Tag_isFollowing_args(topic: topic)
  }

}



fileprivate final class Tag_isFollowing_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Tag_isFollowing_result, rhs: Tag_isFollowing_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Tag_isFollowing_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Tag_isFollowing_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Tag_isFollowing_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Tag_isFollowing_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Tag_isFollowing_result(success: success)
  }

}



extension TagClient : Tag {

  private func send_follow(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "follow", type: .call, sequenceID: 0)
    let args = Tag_follow_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_follow() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Tag_follow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "follow"))
  }

  public func follow(topic: Topic) throws -> Bool {
    try send_follow(topic: topic)
    try outProtocol.transport.flush()
    return try recv_follow()
  }

  private func send_unfollow(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "unfollow", type: .call, sequenceID: 0)
    let args = Tag_unfollow_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unfollow() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Tag_unfollow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "unfollow"))
  }

  public func unfollow(topic: Topic) throws -> Bool {
    try send_unfollow(topic: topic)
    try outProtocol.transport.flush()
    return try recv_unfollow()
  }

  private func send_isFollowing(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "isFollowing", type: .call, sequenceID: 0)
    let args = Tag_isFollowing_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isFollowing() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Tag_isFollowing_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "isFollowing"))
  }

  public func isFollowing(topic: Topic) throws -> Bool {
    try send_isFollowing(topic: topic)
    try outProtocol.transport.flush()
    return try recv_isFollowing()
  }

}

extension TagProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["follow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Tag_follow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Tag_follow_result()
      do {
        result.success = try handler.follow(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "follow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["unfollow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Tag_unfollow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Tag_unfollow_result()
      do {
        result.success = try handler.unfollow(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unfollow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["isFollowing"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Tag_isFollowing_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Tag_isFollowing_result()
      do {
        result.success = try handler.isFollowing(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isFollowing", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = TagProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension TagProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["follow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Tag_follow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.follow(topic: args.topic, completion: { asyncResult in
        var result = Tag_follow_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "follow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "follow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "follow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["unfollow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Tag_unfollow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.unfollow(topic: args.topic, completion: { asyncResult in
        var result = Tag_unfollow_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "unfollow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "unfollow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "unfollow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["isFollowing"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Tag_isFollowing_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.isFollowing(topic: args.topic, completion: { asyncResult in
        var result = Tag_isFollowing_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "isFollowing", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "isFollowing", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "isFollowing", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = TagProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Notifications_follow_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Notifications_follow_args, rhs: Notifications_follow_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Notifications_follow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Notifications_follow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Notifications_follow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_follow_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Notifications_follow_args(topic: topic)
  }

}



fileprivate final class Notifications_follow_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Notifications_follow_result, rhs: Notifications_follow_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Notifications_follow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Notifications_follow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Notifications_follow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_follow_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Notifications_follow_result(success: success)
  }

}



fileprivate final class Notifications_unfollow_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Notifications_unfollow_args, rhs: Notifications_unfollow_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Notifications_unfollow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Notifications_unfollow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Notifications_unfollow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_unfollow_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Notifications_unfollow_args(topic: topic)
  }

}



fileprivate final class Notifications_unfollow_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Notifications_unfollow_result, rhs: Notifications_unfollow_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Notifications_unfollow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Notifications_unfollow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Notifications_unfollow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_unfollow_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Notifications_unfollow_result(success: success)
  }

}



fileprivate final class Notifications_isFollowing_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Notifications_isFollowing_args, rhs: Notifications_isFollowing_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Notifications_isFollowing_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Notifications_isFollowing_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Notifications_isFollowing_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_isFollowing_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Notifications_isFollowing_args(topic: topic)
  }

}



fileprivate final class Notifications_isFollowing_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Notifications_isFollowing_result, rhs: Notifications_isFollowing_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Notifications_isFollowing_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Notifications_isFollowing_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Notifications_isFollowing_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_isFollowing_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Notifications_isFollowing_result(success: success)
  }

}



extension NotificationsClient : Notifications {

  private func send_follow(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "follow", type: .call, sequenceID: 0)
    let args = Notifications_follow_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_follow() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Notifications_follow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "follow"))
  }

  public func follow(topic: Topic) throws -> Bool {
    try send_follow(topic: topic)
    try outProtocol.transport.flush()
    return try recv_follow()
  }

  private func send_unfollow(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "unfollow", type: .call, sequenceID: 0)
    let args = Notifications_unfollow_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unfollow() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Notifications_unfollow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "unfollow"))
  }

  public func unfollow(topic: Topic) throws -> Bool {
    try send_unfollow(topic: topic)
    try outProtocol.transport.flush()
    return try recv_unfollow()
  }

  private func send_isFollowing(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "isFollowing", type: .call, sequenceID: 0)
    let args = Notifications_isFollowing_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isFollowing() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Notifications_isFollowing_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "isFollowing"))
  }

  public func isFollowing(topic: Topic) throws -> Bool {
    try send_isFollowing(topic: topic)
    try outProtocol.transport.flush()
    return try recv_isFollowing()
  }

}

extension NotificationsProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["follow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_follow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Notifications_follow_result()
      do {
        result.success = try handler.follow(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "follow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["unfollow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_unfollow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Notifications_unfollow_result()
      do {
        result.success = try handler.unfollow(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unfollow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["isFollowing"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_isFollowing_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Notifications_isFollowing_result()
      do {
        result.success = try handler.isFollowing(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isFollowing", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NotificationsProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension NotificationsProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["follow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_follow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.follow(topic: args.topic, completion: { asyncResult in
        var result = Notifications_follow_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "follow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "follow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "follow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["unfollow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_unfollow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.unfollow(topic: args.topic, completion: { asyncResult in
        var result = Notifications_unfollow_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "unfollow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "unfollow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "unfollow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["isFollowing"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_isFollowing_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.isFollowing(topic: args.topic, completion: { asyncResult in
        var result = Notifications_isFollowing_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "isFollowing", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "isFollowing", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "isFollowing", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NotificationsProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class User_isPremium_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: User_isPremium_args, rhs: User_isPremium_args) -> Bool {
  return true
}

extension User_isPremium_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension User_isPremium_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "User_isPremium_args" }

  fileprivate static func read(from proto: TProtocol) throws -> User_isPremium_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_isPremium_args()
  }

}



fileprivate final class User_isPremium_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: User_isPremium_result, rhs: User_isPremium_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension User_isPremium_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension User_isPremium_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "User_isPremium_result" }

  fileprivate static func read(from proto: TProtocol) throws -> User_isPremium_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_isPremium_result(success: success)
  }

}



fileprivate final class User_filterSeenArticles_args {

  fileprivate var articleIds: TList<String>


  fileprivate init(articleIds: TList<String>) {
    self.articleIds = articleIds
  }

}

fileprivate func ==(lhs: User_filterSeenArticles_args, rhs: User_filterSeenArticles_args) -> Bool {
  return
    (lhs.articleIds == rhs.articleIds)
}

extension User_filterSeenArticles_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(articleIds)
  }

}

extension User_filterSeenArticles_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["articleIds": 1, ]
  }

  fileprivate static var structName: String { return "User_filterSeenArticles_args" }

  fileprivate static func read(from proto: TProtocol) throws -> User_filterSeenArticles_args {
    _ = try proto.readStructBegin()
    var articleIds: TList<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            articleIds = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(articleIds, named: "articleIds")

    return User_filterSeenArticles_args(articleIds: articleIds)
  }

}



fileprivate final class User_filterSeenArticles_result {

  fileprivate var success: TList<String>?


  fileprivate init() { }
  fileprivate init(success: TList<String>?) {
    self.success = success
  }

}

fileprivate func ==(lhs: User_filterSeenArticles_result, rhs: User_filterSeenArticles_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension User_filterSeenArticles_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension User_filterSeenArticles_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "User_filterSeenArticles_result" }

  fileprivate static func read(from proto: TProtocol) throws -> User_filterSeenArticles_result {
    _ = try proto.readStructBegin()
    var success: TList<String>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_filterSeenArticles_result(success: success)
  }

}



fileprivate final class User_discussionId_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: User_discussionId_args, rhs: User_discussionId_args) -> Bool {
  return true
}

extension User_discussionId_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension User_discussionId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "User_discussionId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> User_discussionId_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_discussionId_args()
  }

}



fileprivate final class User_discussionId_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: User_discussionId_result, rhs: User_discussionId_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension User_discussionId_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension User_discussionId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "User_discussionId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> User_discussionId_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_discussionId_result(success: success)
  }

}



fileprivate final class User_doesCcpaApply_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: User_doesCcpaApply_args, rhs: User_doesCcpaApply_args) -> Bool {
  return true
}

extension User_doesCcpaApply_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension User_doesCcpaApply_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "User_doesCcpaApply_args" }

  fileprivate static func read(from proto: TProtocol) throws -> User_doesCcpaApply_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_doesCcpaApply_args()
  }

}



fileprivate final class User_doesCcpaApply_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: User_doesCcpaApply_result, rhs: User_doesCcpaApply_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension User_doesCcpaApply_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension User_doesCcpaApply_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "User_doesCcpaApply_result" }

  fileprivate static func read(from proto: TProtocol) throws -> User_doesCcpaApply_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_doesCcpaApply_result(success: success)
  }

}



fileprivate final class User_isSignedIn_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: User_isSignedIn_args, rhs: User_isSignedIn_args) -> Bool {
  return true
}

extension User_isSignedIn_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension User_isSignedIn_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "User_isSignedIn_args" }

  fileprivate static func read(from proto: TProtocol) throws -> User_isSignedIn_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_isSignedIn_args()
  }

}



fileprivate final class User_isSignedIn_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: User_isSignedIn_result, rhs: User_isSignedIn_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension User_isSignedIn_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension User_isSignedIn_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "User_isSignedIn_result" }

  fileprivate static func read(from proto: TProtocol) throws -> User_isSignedIn_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_isSignedIn_result(success: success)
  }

}



fileprivate final class User_signIn_args {

  fileprivate var reason: SignInScreenReason

  fileprivate var referrer: SignInScreenReferrer


  fileprivate init(reason: SignInScreenReason, referrer: SignInScreenReferrer) {
    self.reason = reason
    self.referrer = referrer
  }

}

fileprivate func ==(lhs: User_signIn_args, rhs: User_signIn_args) -> Bool {
  return
    (lhs.reason == rhs.reason) &&
    (lhs.referrer == rhs.referrer)
}

extension User_signIn_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(reason)
    hasher.combine(referrer)
  }

}

extension User_signIn_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["reason": 1, "referrer": 2, ]
  }

  fileprivate static var structName: String { return "User_signIn_args" }

  fileprivate static func read(from proto: TProtocol) throws -> User_signIn_args {
    _ = try proto.readStructBegin()
    var reason: SignInScreenReason!
    var referrer: SignInScreenReferrer!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             reason = try SignInScreenReason.read(from: proto)
        case (2, .i32):             referrer = try SignInScreenReferrer.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reason, named: "reason")
    try proto.validateValue(referrer, named: "referrer")

    return User_signIn_args(reason: reason, referrer: referrer)
  }

}



fileprivate final class User_signIn_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: User_signIn_result, rhs: User_signIn_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension User_signIn_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension User_signIn_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "User_signIn_result" }

  fileprivate static func read(from proto: TProtocol) throws -> User_signIn_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_signIn_result(success: success)
  }

}



extension UserClient : User {

  private func send_isPremium() throws {
    try outProtocol.writeMessageBegin(name: "isPremium", type: .call, sequenceID: 0)
    let args = User_isPremium_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isPremium() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try User_isPremium_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "isPremium"))
  }

  public func isPremium() throws -> Bool {
    try send_isPremium()
    try outProtocol.transport.flush()
    return try recv_isPremium()
  }

  private func send_filterSeenArticles(articleIds: TList<String>) throws {
    try outProtocol.writeMessageBegin(name: "filterSeenArticles", type: .call, sequenceID: 0)
    let args = User_filterSeenArticles_args(articleIds: articleIds)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_filterSeenArticles() throws -> TList<String> {
    try inProtocol.readResultMessageBegin() 
    let result = try User_filterSeenArticles_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "filterSeenArticles"))
  }

  public func filterSeenArticles(articleIds: TList<String>) throws -> TList<String> {
    try send_filterSeenArticles(articleIds: articleIds)
    try outProtocol.transport.flush()
    return try recv_filterSeenArticles()
  }

  private func send_discussionId() throws {
    try outProtocol.writeMessageBegin(name: "discussionId", type: .call, sequenceID: 0)
    let args = User_discussionId_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_discussionId() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try User_discussionId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "discussionId"))
  }

  public func discussionId() throws -> String {
    try send_discussionId()
    try outProtocol.transport.flush()
    return try recv_discussionId()
  }

  private func send_doesCcpaApply() throws {
    try outProtocol.writeMessageBegin(name: "doesCcpaApply", type: .call, sequenceID: 0)
    let args = User_doesCcpaApply_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_doesCcpaApply() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try User_doesCcpaApply_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "doesCcpaApply"))
  }

  public func doesCcpaApply() throws -> Bool {
    try send_doesCcpaApply()
    try outProtocol.transport.flush()
    return try recv_doesCcpaApply()
  }

  private func send_isSignedIn() throws {
    try outProtocol.writeMessageBegin(name: "isSignedIn", type: .call, sequenceID: 0)
    let args = User_isSignedIn_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isSignedIn() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try User_isSignedIn_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "isSignedIn"))
  }

  public func isSignedIn() throws -> Bool {
    try send_isSignedIn()
    try outProtocol.transport.flush()
    return try recv_isSignedIn()
  }

  private func send_signIn(reason: SignInScreenReason, referrer: SignInScreenReferrer) throws {
    try outProtocol.writeMessageBegin(name: "signIn", type: .call, sequenceID: 0)
    let args = User_signIn_args(reason: reason, referrer: referrer)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_signIn() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try User_signIn_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "signIn"))
  }

  public func signIn(reason: SignInScreenReason, referrer: SignInScreenReferrer) throws -> Bool {
    try send_signIn(reason: reason, referrer: referrer)
    try outProtocol.transport.flush()
    return try recv_signIn()
  }

}

extension UserProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["isPremium"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_isPremium_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = User_isPremium_result()
      do {
        result.success = try handler.isPremium()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isPremium", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["filterSeenArticles"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_filterSeenArticles_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = User_filterSeenArticles_result()
      do {
        result.success = try handler.filterSeenArticles(articleIds: args.articleIds)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "filterSeenArticles", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["discussionId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_discussionId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = User_discussionId_result()
      do {
        result.success = try handler.discussionId()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "discussionId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["doesCcpaApply"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_doesCcpaApply_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = User_doesCcpaApply_result()
      do {
        result.success = try handler.doesCcpaApply()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "doesCcpaApply", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["isSignedIn"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_isSignedIn_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = User_isSignedIn_result()
      do {
        result.success = try handler.isSignedIn()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isSignedIn", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["signIn"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_signIn_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = User_signIn_result()
      do {
        result.success = try handler.signIn(reason: args.reason, referrer: args.referrer)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "signIn", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = UserProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension UserProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["isPremium"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_isPremium_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.isPremium(completion: { asyncResult in
        var result = User_isPremium_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "isPremium", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "isPremium", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "isPremium", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["filterSeenArticles"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_filterSeenArticles_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.filterSeenArticles(articleIds: args.articleIds, completion: { asyncResult in
        var result = User_filterSeenArticles_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "filterSeenArticles", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "filterSeenArticles", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "filterSeenArticles", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["discussionId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_discussionId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.discussionId(completion: { asyncResult in
        var result = User_discussionId_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "discussionId", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "discussionId", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "discussionId", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["doesCcpaApply"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_doesCcpaApply_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.doesCcpaApply(completion: { asyncResult in
        var result = User_doesCcpaApply_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "doesCcpaApply", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "doesCcpaApply", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "doesCcpaApply", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["isSignedIn"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_isSignedIn_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.isSignedIn(completion: { asyncResult in
        var result = User_isSignedIn_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "isSignedIn", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "isSignedIn", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "isSignedIn", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["signIn"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_signIn_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.signIn(reason: args.reason, referrer: args.referrer, completion: { asyncResult in
        var result = User_signIn_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "signIn", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "signIn", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "signIn", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = UserProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Gallery_launchSlideshow_args {

  fileprivate var images: TList<Image>

  fileprivate var selectedIndex: Int32

  fileprivate var articleTitle: String


  fileprivate init(images: TList<Image>, selectedIndex: Int32, articleTitle: String) {
    self.images = images
    self.selectedIndex = selectedIndex
    self.articleTitle = articleTitle
  }

}

fileprivate func ==(lhs: Gallery_launchSlideshow_args, rhs: Gallery_launchSlideshow_args) -> Bool {
  return
    (lhs.images == rhs.images) &&
    (lhs.selectedIndex == rhs.selectedIndex) &&
    (lhs.articleTitle == rhs.articleTitle)
}

extension Gallery_launchSlideshow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(images)
    hasher.combine(selectedIndex)
    hasher.combine(articleTitle)
  }

}

extension Gallery_launchSlideshow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["images": 1, "selectedIndex": 2, "articleTitle": 3, ]
  }

  fileprivate static var structName: String { return "Gallery_launchSlideshow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Gallery_launchSlideshow_args {
    _ = try proto.readStructBegin()
    var images: TList<Image>!
    var selectedIndex: Int32!
    var articleTitle: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            images = try TList<Image>.read(from: proto)
        case (2, .i32):             selectedIndex = try Int32.read(from: proto)
        case (3, .string):           articleTitle = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(images, named: "images")
    try proto.validateValue(selectedIndex, named: "selectedIndex")
    try proto.validateValue(articleTitle, named: "articleTitle")

    return Gallery_launchSlideshow_args(images: images, selectedIndex: selectedIndex, articleTitle: articleTitle)
  }

}



fileprivate final class Gallery_launchSlideshow_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Gallery_launchSlideshow_result, rhs: Gallery_launchSlideshow_result) -> Bool {
  return true
}

extension Gallery_launchSlideshow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Gallery_launchSlideshow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Gallery_launchSlideshow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Gallery_launchSlideshow_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Gallery_launchSlideshow_result()
  }

}



extension GalleryClient : Gallery {

  private func send_launchSlideshow(images: TList<Image>, selectedIndex: Int32, articleTitle: String) throws {
    try outProtocol.writeMessageBegin(name: "launchSlideshow", type: .call, sequenceID: 0)
    let args = Gallery_launchSlideshow_args(images: images, selectedIndex: selectedIndex, articleTitle: articleTitle)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_launchSlideshow() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Gallery_launchSlideshow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func launchSlideshow(images: TList<Image>, selectedIndex: Int32, articleTitle: String) throws {
    try send_launchSlideshow(images: images, selectedIndex: selectedIndex, articleTitle: articleTitle)
    try outProtocol.transport.flush()
    try recv_launchSlideshow()
  }

}

extension GalleryProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchSlideshow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Gallery_launchSlideshow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Gallery_launchSlideshow_result()
      do {
        try handler.launchSlideshow(images: args.images, selectedIndex: args.selectedIndex, articleTitle: args.articleTitle)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "launchSlideshow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = GalleryProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension GalleryProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchSlideshow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Gallery_launchSlideshow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.launchSlideshow(images: args.images, selectedIndex: args.selectedIndex, articleTitle: args.articleTitle, completion: { asyncResult in
        var result = Gallery_launchSlideshow_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "launchSlideshow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "launchSlideshow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "launchSlideshow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = GalleryProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Videos_insertVideos_args {

  fileprivate var videoSlots: TList<VideoSlot>


  fileprivate init(videoSlots: TList<VideoSlot>) {
    self.videoSlots = videoSlots
  }

}

fileprivate func ==(lhs: Videos_insertVideos_args, rhs: Videos_insertVideos_args) -> Bool {
  return
    (lhs.videoSlots == rhs.videoSlots)
}

extension Videos_insertVideos_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(videoSlots)
  }

}

extension Videos_insertVideos_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["videoSlots": 1, ]
  }

  fileprivate static var structName: String { return "Videos_insertVideos_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_insertVideos_args {
    _ = try proto.readStructBegin()
    var videoSlots: TList<VideoSlot>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            videoSlots = try TList<VideoSlot>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(videoSlots, named: "videoSlots")

    return Videos_insertVideos_args(videoSlots: videoSlots)
  }

}



fileprivate final class Videos_insertVideos_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Videos_insertVideos_result, rhs: Videos_insertVideos_result) -> Bool {
  return true
}

extension Videos_insertVideos_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Videos_insertVideos_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Videos_insertVideos_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_insertVideos_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Videos_insertVideos_result()
  }

}



fileprivate final class Videos_updateVideos_args {

  fileprivate var videoSlots: TList<VideoSlot>


  fileprivate init(videoSlots: TList<VideoSlot>) {
    self.videoSlots = videoSlots
  }

}

fileprivate func ==(lhs: Videos_updateVideos_args, rhs: Videos_updateVideos_args) -> Bool {
  return
    (lhs.videoSlots == rhs.videoSlots)
}

extension Videos_updateVideos_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(videoSlots)
  }

}

extension Videos_updateVideos_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["videoSlots": 1, ]
  }

  fileprivate static var structName: String { return "Videos_updateVideos_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_updateVideos_args {
    _ = try proto.readStructBegin()
    var videoSlots: TList<VideoSlot>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            videoSlots = try TList<VideoSlot>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(videoSlots, named: "videoSlots")

    return Videos_updateVideos_args(videoSlots: videoSlots)
  }

}



fileprivate final class Videos_updateVideos_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Videos_updateVideos_result, rhs: Videos_updateVideos_result) -> Bool {
  return true
}

extension Videos_updateVideos_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Videos_updateVideos_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Videos_updateVideos_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_updateVideos_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Videos_updateVideos_result()
  }

}



fileprivate final class Videos_sendVideoEvent_args {

  fileprivate var videoEvent: VideoEvent


  fileprivate init(videoEvent: VideoEvent) {
    self.videoEvent = videoEvent
  }

}

fileprivate func ==(lhs: Videos_sendVideoEvent_args, rhs: Videos_sendVideoEvent_args) -> Bool {
  return
    (lhs.videoEvent == rhs.videoEvent)
}

extension Videos_sendVideoEvent_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(videoEvent)
  }

}

extension Videos_sendVideoEvent_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["videoEvent": 1, ]
  }

  fileprivate static var structName: String { return "Videos_sendVideoEvent_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_sendVideoEvent_args {
    _ = try proto.readStructBegin()
    var videoEvent: VideoEvent!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           videoEvent = try VideoEvent.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(videoEvent, named: "videoEvent")

    return Videos_sendVideoEvent_args(videoEvent: videoEvent)
  }

}



fileprivate final class Videos_sendVideoEvent_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Videos_sendVideoEvent_result, rhs: Videos_sendVideoEvent_result) -> Bool {
  return true
}

extension Videos_sendVideoEvent_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Videos_sendVideoEvent_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Videos_sendVideoEvent_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_sendVideoEvent_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Videos_sendVideoEvent_result()
  }

}



fileprivate final class Videos_setFullscreen_args {

  fileprivate var isFullscreen: Bool


  fileprivate init(isFullscreen: Bool) {
    self.isFullscreen = isFullscreen
  }

}

fileprivate func ==(lhs: Videos_setFullscreen_args, rhs: Videos_setFullscreen_args) -> Bool {
  return
    (lhs.isFullscreen == rhs.isFullscreen)
}

extension Videos_setFullscreen_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(isFullscreen)
  }

}

extension Videos_setFullscreen_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["isFullscreen": 1, ]
  }

  fileprivate static var structName: String { return "Videos_setFullscreen_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_setFullscreen_args {
    _ = try proto.readStructBegin()
    var isFullscreen: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            isFullscreen = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(isFullscreen, named: "isFullscreen")

    return Videos_setFullscreen_args(isFullscreen: isFullscreen)
  }

}



fileprivate final class Videos_setFullscreen_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Videos_setFullscreen_result, rhs: Videos_setFullscreen_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Videos_setFullscreen_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Videos_setFullscreen_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Videos_setFullscreen_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Videos_setFullscreen_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Videos_setFullscreen_result(success: success)
  }

}



extension VideosClient : Videos {

  private func send_insertVideos(videoSlots: TList<VideoSlot>) throws {
    try outProtocol.writeMessageBegin(name: "insertVideos", type: .call, sequenceID: 0)
    let args = Videos_insertVideos_args(videoSlots: videoSlots)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_insertVideos() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Videos_insertVideos_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func insertVideos(videoSlots: TList<VideoSlot>) throws {
    try send_insertVideos(videoSlots: videoSlots)
    try outProtocol.transport.flush()
    try recv_insertVideos()
  }

  private func send_updateVideos(videoSlots: TList<VideoSlot>) throws {
    try outProtocol.writeMessageBegin(name: "updateVideos", type: .call, sequenceID: 0)
    let args = Videos_updateVideos_args(videoSlots: videoSlots)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateVideos() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Videos_updateVideos_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func updateVideos(videoSlots: TList<VideoSlot>) throws {
    try send_updateVideos(videoSlots: videoSlots)
    try outProtocol.transport.flush()
    try recv_updateVideos()
  }

  private func send_sendVideoEvent(videoEvent: VideoEvent) throws {
    try outProtocol.writeMessageBegin(name: "sendVideoEvent", type: .call, sequenceID: 0)
    let args = Videos_sendVideoEvent_args(videoEvent: videoEvent)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendVideoEvent() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Videos_sendVideoEvent_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func sendVideoEvent(videoEvent: VideoEvent) throws {
    try send_sendVideoEvent(videoEvent: videoEvent)
    try outProtocol.transport.flush()
    try recv_sendVideoEvent()
  }

  private func send_setFullscreen(isFullscreen: Bool) throws {
    try outProtocol.writeMessageBegin(name: "setFullscreen", type: .call, sequenceID: 0)
    let args = Videos_setFullscreen_args(isFullscreen: isFullscreen)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_setFullscreen() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Videos_setFullscreen_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "setFullscreen"))
  }

  public func setFullscreen(isFullscreen: Bool) throws -> Bool {
    try send_setFullscreen(isFullscreen: isFullscreen)
    try outProtocol.transport.flush()
    return try recv_setFullscreen()
  }

}

extension VideosProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["insertVideos"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_insertVideos_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Videos_insertVideos_result()
      do {
        try handler.insertVideos(videoSlots: args.videoSlots)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "insertVideos", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["updateVideos"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_updateVideos_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Videos_updateVideos_result()
      do {
        try handler.updateVideos(videoSlots: args.videoSlots)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateVideos", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["sendVideoEvent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_sendVideoEvent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Videos_sendVideoEvent_result()
      do {
        try handler.sendVideoEvent(videoEvent: args.videoEvent)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendVideoEvent", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["setFullscreen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_setFullscreen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Videos_setFullscreen_result()
      do {
        result.success = try handler.setFullscreen(isFullscreen: args.isFullscreen)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "setFullscreen", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = VideosProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension VideosProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["insertVideos"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_insertVideos_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.insertVideos(videoSlots: args.videoSlots, completion: { asyncResult in
        var result = Videos_insertVideos_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "insertVideos", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "insertVideos", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "insertVideos", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["updateVideos"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_updateVideos_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.updateVideos(videoSlots: args.videoSlots, completion: { asyncResult in
        var result = Videos_updateVideos_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "updateVideos", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "updateVideos", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "updateVideos", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["sendVideoEvent"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_sendVideoEvent_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.sendVideoEvent(videoEvent: args.videoEvent, completion: { asyncResult in
        var result = Videos_sendVideoEvent_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "sendVideoEvent", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "sendVideoEvent", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "sendVideoEvent", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["setFullscreen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Videos_setFullscreen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.setFullscreen(isFullscreen: args.isFullscreen, completion: { asyncResult in
        var result = Videos_setFullscreen_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "setFullscreen", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "setFullscreen", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "setFullscreen", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = VideosProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Metrics_sendMetrics_args {

  fileprivate var metrics: TList<Metric>


  fileprivate init(metrics: TList<Metric>) {
    self.metrics = metrics
  }

}

fileprivate func ==(lhs: Metrics_sendMetrics_args, rhs: Metrics_sendMetrics_args) -> Bool {
  return
    (lhs.metrics == rhs.metrics)
}

extension Metrics_sendMetrics_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(metrics)
  }

}

extension Metrics_sendMetrics_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["metrics": 1, ]
  }

  fileprivate static var structName: String { return "Metrics_sendMetrics_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Metrics_sendMetrics_args {
    _ = try proto.readStructBegin()
    var metrics: TList<Metric>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            metrics = try TList<Metric>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(metrics, named: "metrics")

    return Metrics_sendMetrics_args(metrics: metrics)
  }

}



fileprivate final class Metrics_sendMetrics_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Metrics_sendMetrics_result, rhs: Metrics_sendMetrics_result) -> Bool {
  return true
}

extension Metrics_sendMetrics_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Metrics_sendMetrics_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Metrics_sendMetrics_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Metrics_sendMetrics_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Metrics_sendMetrics_result()
  }

}



extension MetricsClient : Metrics {

  private func send_sendMetrics(metrics: TList<Metric>) throws {
    try outProtocol.writeMessageBegin(name: "sendMetrics", type: .call, sequenceID: 0)
    let args = Metrics_sendMetrics_args(metrics: metrics)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMetrics() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Metrics_sendMetrics_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func sendMetrics(metrics: TList<Metric>) throws {
    try send_sendMetrics(metrics: metrics)
    try outProtocol.transport.flush()
    try recv_sendMetrics()
  }

}

extension MetricsProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["sendMetrics"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Metrics_sendMetrics_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Metrics_sendMetrics_result()
      do {
        try handler.sendMetrics(metrics: args.metrics)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMetrics", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = MetricsProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension MetricsProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["sendMetrics"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Metrics_sendMetrics_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.sendMetrics(metrics: args.metrics, completion: { asyncResult in
        var result = Metrics_sendMetrics_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "sendMetrics", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "sendMetrics", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "sendMetrics", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = MetricsProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Discussion_recommend_args {

  fileprivate var commentId: String


  fileprivate init(commentId: String) {
    self.commentId = commentId
  }

}

fileprivate func ==(lhs: Discussion_recommend_args, rhs: Discussion_recommend_args) -> Bool {
  return
    (lhs.commentId == rhs.commentId)
}

extension Discussion_recommend_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(commentId)
  }

}

extension Discussion_recommend_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["commentId": 1, ]
  }

  fileprivate static var structName: String { return "Discussion_recommend_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_recommend_args {
    _ = try proto.readStructBegin()
    var commentId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           commentId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(commentId, named: "commentId")

    return Discussion_recommend_args(commentId: commentId)
  }

}



fileprivate final class Discussion_recommend_result {

  fileprivate var success: DiscussionServiceResponse?


  fileprivate init() { }
  fileprivate init(success: DiscussionServiceResponse?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Discussion_recommend_result, rhs: Discussion_recommend_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Discussion_recommend_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Discussion_recommend_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Discussion_recommend_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_recommend_result {
    _ = try proto.readStructBegin()
    var success: DiscussionServiceResponse?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try DiscussionServiceResponse.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Discussion_recommend_result(success: success)
  }

}



fileprivate final class Discussion_comment_args {

  fileprivate var shortUrl: String

  fileprivate var body: String


  fileprivate init(shortUrl: String, body: String) {
    self.shortUrl = shortUrl
    self.body = body
  }

}

fileprivate func ==(lhs: Discussion_comment_args, rhs: Discussion_comment_args) -> Bool {
  return
    (lhs.shortUrl == rhs.shortUrl) &&
    (lhs.body == rhs.body)
}

extension Discussion_comment_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(shortUrl)
    hasher.combine(body)
  }

}

extension Discussion_comment_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["shortUrl": 1, "body": 2, ]
  }

  fileprivate static var structName: String { return "Discussion_comment_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_comment_args {
    _ = try proto.readStructBegin()
    var shortUrl: String!
    var body: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           shortUrl = try String.read(from: proto)
        case (2, .string):           body = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(shortUrl, named: "shortUrl")
    try proto.validateValue(body, named: "body")

    return Discussion_comment_args(shortUrl: shortUrl, body: body)
  }

}



fileprivate final class Discussion_comment_result {

  fileprivate var success: DiscussionServiceResponse?


  fileprivate init() { }
  fileprivate init(success: DiscussionServiceResponse?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Discussion_comment_result, rhs: Discussion_comment_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Discussion_comment_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Discussion_comment_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Discussion_comment_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_comment_result {
    _ = try proto.readStructBegin()
    var success: DiscussionServiceResponse?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try DiscussionServiceResponse.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Discussion_comment_result(success: success)
  }

}



fileprivate final class Discussion_reply_args {

  fileprivate var shortUrl: String

  fileprivate var body: String

  fileprivate var parentCommentId: String


  fileprivate init(shortUrl: String, body: String, parentCommentId: String) {
    self.shortUrl = shortUrl
    self.body = body
    self.parentCommentId = parentCommentId
  }

}

fileprivate func ==(lhs: Discussion_reply_args, rhs: Discussion_reply_args) -> Bool {
  return
    (lhs.shortUrl == rhs.shortUrl) &&
    (lhs.body == rhs.body) &&
    (lhs.parentCommentId == rhs.parentCommentId)
}

extension Discussion_reply_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(shortUrl)
    hasher.combine(body)
    hasher.combine(parentCommentId)
  }

}

extension Discussion_reply_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["shortUrl": 1, "body": 2, "parentCommentId": 3, ]
  }

  fileprivate static var structName: String { return "Discussion_reply_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_reply_args {
    _ = try proto.readStructBegin()
    var shortUrl: String!
    var body: String!
    var parentCommentId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           shortUrl = try String.read(from: proto)
        case (2, .string):           body = try String.read(from: proto)
        case (3, .string):           parentCommentId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(shortUrl, named: "shortUrl")
    try proto.validateValue(body, named: "body")
    try proto.validateValue(parentCommentId, named: "parentCommentId")

    return Discussion_reply_args(shortUrl: shortUrl, body: body, parentCommentId: parentCommentId)
  }

}



fileprivate final class Discussion_reply_result {

  fileprivate var success: DiscussionServiceResponse?


  fileprivate init() { }
  fileprivate init(success: DiscussionServiceResponse?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Discussion_reply_result, rhs: Discussion_reply_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Discussion_reply_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Discussion_reply_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Discussion_reply_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_reply_result {
    _ = try proto.readStructBegin()
    var success: DiscussionServiceResponse?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try DiscussionServiceResponse.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Discussion_reply_result(success: success)
  }

}



fileprivate final class Discussion_getUserProfile_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Discussion_getUserProfile_args, rhs: Discussion_getUserProfile_args) -> Bool {
  return true
}

extension Discussion_getUserProfile_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Discussion_getUserProfile_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Discussion_getUserProfile_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_getUserProfile_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Discussion_getUserProfile_args()
  }

}



fileprivate final class Discussion_getUserProfile_result {

  fileprivate var success: DiscussionServiceResponse?


  fileprivate init() { }
  fileprivate init(success: DiscussionServiceResponse?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Discussion_getUserProfile_result, rhs: Discussion_getUserProfile_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Discussion_getUserProfile_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Discussion_getUserProfile_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Discussion_getUserProfile_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Discussion_getUserProfile_result {
    _ = try proto.readStructBegin()
    var success: DiscussionServiceResponse?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try DiscussionServiceResponse.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Discussion_getUserProfile_result(success: success)
  }

}



extension DiscussionClient : Discussion {

  private func send_recommend(commentId: String) throws {
    try outProtocol.writeMessageBegin(name: "recommend", type: .call, sequenceID: 0)
    let args = Discussion_recommend_args(commentId: commentId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_recommend() throws -> DiscussionServiceResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try Discussion_recommend_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "recommend"))
  }

  public func recommend(commentId: String) throws -> DiscussionServiceResponse {
    try send_recommend(commentId: commentId)
    try outProtocol.transport.flush()
    return try recv_recommend()
  }

  private func send_comment(shortUrl: String, body: String) throws {
    try outProtocol.writeMessageBegin(name: "comment", type: .call, sequenceID: 0)
    let args = Discussion_comment_args(shortUrl: shortUrl, body: body)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_comment() throws -> DiscussionServiceResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try Discussion_comment_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "comment"))
  }

  public func comment(shortUrl: String, body: String) throws -> DiscussionServiceResponse {
    try send_comment(shortUrl: shortUrl, body: body)
    try outProtocol.transport.flush()
    return try recv_comment()
  }

  private func send_reply(shortUrl: String, body: String, parentCommentId: String) throws {
    try outProtocol.writeMessageBegin(name: "reply", type: .call, sequenceID: 0)
    let args = Discussion_reply_args(shortUrl: shortUrl, body: body, parentCommentId: parentCommentId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_reply() throws -> DiscussionServiceResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try Discussion_reply_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "reply"))
  }

  public func reply(shortUrl: String, body: String, parentCommentId: String) throws -> DiscussionServiceResponse {
    try send_reply(shortUrl: shortUrl, body: body, parentCommentId: parentCommentId)
    try outProtocol.transport.flush()
    return try recv_reply()
  }

  private func send_getUserProfile() throws {
    try outProtocol.writeMessageBegin(name: "getUserProfile", type: .call, sequenceID: 0)
    let args = Discussion_getUserProfile_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getUserProfile() throws -> DiscussionServiceResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try Discussion_getUserProfile_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "getUserProfile"))
  }

  public func getUserProfile() throws -> DiscussionServiceResponse {
    try send_getUserProfile()
    try outProtocol.transport.flush()
    return try recv_getUserProfile()
  }

}

extension DiscussionProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["recommend"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_recommend_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Discussion_recommend_result()
      do {
        result.success = try handler.recommend(commentId: args.commentId)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "recommend", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["comment"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_comment_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Discussion_comment_result()
      do {
        result.success = try handler.comment(shortUrl: args.shortUrl, body: args.body)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "comment", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["reply"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_reply_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Discussion_reply_result()
      do {
        result.success = try handler.reply(shortUrl: args.shortUrl, body: args.body, parentCommentId: args.parentCommentId)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "reply", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["getUserProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_getUserProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Discussion_getUserProfile_result()
      do {
        result.success = try handler.getUserProfile()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getUserProfile", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = DiscussionProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension DiscussionProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["recommend"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_recommend_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.recommend(commentId: args.commentId, completion: { asyncResult in
        var result = Discussion_recommend_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "recommend", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "recommend", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "recommend", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["comment"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_comment_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.comment(shortUrl: args.shortUrl, body: args.body, completion: { asyncResult in
        var result = Discussion_comment_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "comment", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "comment", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "comment", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["reply"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_reply_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.reply(shortUrl: args.shortUrl, body: args.body, parentCommentId: args.parentCommentId, completion: { asyncResult in
        var result = Discussion_reply_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "reply", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "reply", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "reply", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["getUserProfile"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Discussion_getUserProfile_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.getUserProfile(completion: { asyncResult in
        var result = Discussion_getUserProfile_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "getUserProfile", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "getUserProfile", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "getUserProfile", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = DiscussionProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Analytics_sendTargetingParams_args {

  fileprivate var targetingParams: TMap<String, String>


  fileprivate init(targetingParams: TMap<String, String>) {
    self.targetingParams = targetingParams
  }

}

fileprivate func ==(lhs: Analytics_sendTargetingParams_args, rhs: Analytics_sendTargetingParams_args) -> Bool {
  return
    (lhs.targetingParams == rhs.targetingParams)
}

extension Analytics_sendTargetingParams_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(targetingParams)
  }

}

extension Analytics_sendTargetingParams_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["targetingParams": 1, ]
  }

  fileprivate static var structName: String { return "Analytics_sendTargetingParams_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Analytics_sendTargetingParams_args {
    _ = try proto.readStructBegin()
    var targetingParams: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .map):             targetingParams = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(targetingParams, named: "targetingParams")

    return Analytics_sendTargetingParams_args(targetingParams: targetingParams)
  }

}



fileprivate final class Analytics_sendTargetingParams_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Analytics_sendTargetingParams_result, rhs: Analytics_sendTargetingParams_result) -> Bool {
  return true
}

extension Analytics_sendTargetingParams_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Analytics_sendTargetingParams_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Analytics_sendTargetingParams_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Analytics_sendTargetingParams_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Analytics_sendTargetingParams_result()
  }

}



extension AnalyticsClient : Analytics {

  private func send_sendTargetingParams(targetingParams: TMap<String, String>) throws {
    try outProtocol.writeMessageBegin(name: "sendTargetingParams", type: .call, sequenceID: 0)
    let args = Analytics_sendTargetingParams_args(targetingParams: targetingParams)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendTargetingParams() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Analytics_sendTargetingParams_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func sendTargetingParams(targetingParams: TMap<String, String>) throws {
    try send_sendTargetingParams(targetingParams: targetingParams)
    try outProtocol.transport.flush()
    try recv_sendTargetingParams()
  }

}

extension AnalyticsProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["sendTargetingParams"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Analytics_sendTargetingParams_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Analytics_sendTargetingParams_result()
      do {
        try handler.sendTargetingParams(targetingParams: args.targetingParams)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendTargetingParams", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AnalyticsProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension AnalyticsProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["sendTargetingParams"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Analytics_sendTargetingParams_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.sendTargetingParams(targetingParams: args.targetingParams, completion: { asyncResult in
        var result = Analytics_sendTargetingParams_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "sendTargetingParams", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "sendTargetingParams", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "sendTargetingParams", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AnalyticsProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Navigation_openPrivacySettings_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Navigation_openPrivacySettings_args, rhs: Navigation_openPrivacySettings_args) -> Bool {
  return true
}

extension Navigation_openPrivacySettings_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Navigation_openPrivacySettings_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Navigation_openPrivacySettings_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Navigation_openPrivacySettings_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Navigation_openPrivacySettings_args()
  }

}



fileprivate final class Navigation_openPrivacySettings_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Navigation_openPrivacySettings_result, rhs: Navigation_openPrivacySettings_result) -> Bool {
  return true
}

extension Navigation_openPrivacySettings_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Navigation_openPrivacySettings_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Navigation_openPrivacySettings_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Navigation_openPrivacySettings_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Navigation_openPrivacySettings_result()
  }

}



fileprivate final class Navigation_openPrivacyPolicy_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Navigation_openPrivacyPolicy_args, rhs: Navigation_openPrivacyPolicy_args) -> Bool {
  return true
}

extension Navigation_openPrivacyPolicy_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Navigation_openPrivacyPolicy_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Navigation_openPrivacyPolicy_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Navigation_openPrivacyPolicy_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Navigation_openPrivacyPolicy_args()
  }

}



fileprivate final class Navigation_openPrivacyPolicy_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Navigation_openPrivacyPolicy_result, rhs: Navigation_openPrivacyPolicy_result) -> Bool {
  return true
}

extension Navigation_openPrivacyPolicy_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Navigation_openPrivacyPolicy_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Navigation_openPrivacyPolicy_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Navigation_openPrivacyPolicy_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Navigation_openPrivacyPolicy_result()
  }

}



extension NavigationClient : Navigation {

  private func send_openPrivacySettings() throws {
    try outProtocol.writeMessageBegin(name: "openPrivacySettings", type: .call, sequenceID: 0)
    let args = Navigation_openPrivacySettings_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_openPrivacySettings() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Navigation_openPrivacySettings_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func openPrivacySettings() throws {
    try send_openPrivacySettings()
    try outProtocol.transport.flush()
    try recv_openPrivacySettings()
  }

  private func send_openPrivacyPolicy() throws {
    try outProtocol.writeMessageBegin(name: "openPrivacyPolicy", type: .call, sequenceID: 0)
    let args = Navigation_openPrivacyPolicy_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_openPrivacyPolicy() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Navigation_openPrivacyPolicy_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func openPrivacyPolicy() throws {
    try send_openPrivacyPolicy()
    try outProtocol.transport.flush()
    try recv_openPrivacyPolicy()
  }

}

extension NavigationProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["openPrivacySettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Navigation_openPrivacySettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Navigation_openPrivacySettings_result()
      do {
        try handler.openPrivacySettings()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "openPrivacySettings", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    processorHandlers["openPrivacyPolicy"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Navigation_openPrivacyPolicy_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Navigation_openPrivacyPolicy_result()
      do {
        try handler.openPrivacyPolicy()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "openPrivacyPolicy", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NavigationProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension NavigationProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["openPrivacySettings"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Navigation_openPrivacySettings_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.openPrivacySettings(completion: { asyncResult in
        var result = Navigation_openPrivacySettings_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "openPrivacySettings", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "openPrivacySettings", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "openPrivacySettings", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["openPrivacyPolicy"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Navigation_openPrivacyPolicy_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.openPrivacyPolicy(completion: { asyncResult in
        var result = Navigation_openPrivacyPolicy_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "openPrivacyPolicy", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "openPrivacyPolicy", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "openPrivacyPolicy", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NavigationProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Newsletters_requestSignUp_args {

  fileprivate var emailAddress: String

  fileprivate var newsletterIdentityName: String


  fileprivate init(emailAddress: String, newsletterIdentityName: String) {
    self.emailAddress = emailAddress
    self.newsletterIdentityName = newsletterIdentityName
  }

}

fileprivate func ==(lhs: Newsletters_requestSignUp_args, rhs: Newsletters_requestSignUp_args) -> Bool {
  return
    (lhs.emailAddress == rhs.emailAddress) &&
    (lhs.newsletterIdentityName == rhs.newsletterIdentityName)
}

extension Newsletters_requestSignUp_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(emailAddress)
    hasher.combine(newsletterIdentityName)
  }

}

extension Newsletters_requestSignUp_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["emailAddress": 1, "newsletterIdentityName": 2, ]
  }

  fileprivate static var structName: String { return "Newsletters_requestSignUp_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Newsletters_requestSignUp_args {
    _ = try proto.readStructBegin()
    var emailAddress: String!
    var newsletterIdentityName: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           emailAddress = try String.read(from: proto)
        case (2, .string):           newsletterIdentityName = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(emailAddress, named: "emailAddress")
    try proto.validateValue(newsletterIdentityName, named: "newsletterIdentityName")

    return Newsletters_requestSignUp_args(emailAddress: emailAddress, newsletterIdentityName: newsletterIdentityName)
  }

}



fileprivate final class Newsletters_requestSignUp_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Newsletters_requestSignUp_result, rhs: Newsletters_requestSignUp_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Newsletters_requestSignUp_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Newsletters_requestSignUp_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Newsletters_requestSignUp_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Newsletters_requestSignUp_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Newsletters_requestSignUp_result(success: success)
  }

}



extension NewslettersClient : Newsletters {

  private func send_requestSignUp(emailAddress: String, newsletterIdentityName: String) throws {
    try outProtocol.writeMessageBegin(name: "requestSignUp", type: .call, sequenceID: 0)
    let args = Newsletters_requestSignUp_args(emailAddress: emailAddress, newsletterIdentityName: newsletterIdentityName)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_requestSignUp() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Newsletters_requestSignUp_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "requestSignUp"))
  }

  public func requestSignUp(emailAddress: String, newsletterIdentityName: String) throws -> Bool {
    try send_requestSignUp(emailAddress: emailAddress, newsletterIdentityName: newsletterIdentityName)
    try outProtocol.transport.flush()
    return try recv_requestSignUp()
  }

}

extension NewslettersProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["requestSignUp"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Newsletters_requestSignUp_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Newsletters_requestSignUp_result()
      do {
        result.success = try handler.requestSignUp(emailAddress: args.emailAddress, newsletterIdentityName: args.newsletterIdentityName)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "requestSignUp", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NewslettersProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension NewslettersProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["requestSignUp"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Newsletters_requestSignUp_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.requestSignUp(emailAddress: args.emailAddress, newsletterIdentityName: args.newsletterIdentityName, completion: { asyncResult in
        var result = Newsletters_requestSignUp_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "requestSignUp", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "requestSignUp", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "requestSignUp", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NewslettersProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Interaction_disableArticleSwipe_args {

  fileprivate var disableSwipe: Bool


  fileprivate init(disableSwipe: Bool) {
    self.disableSwipe = disableSwipe
  }

}

fileprivate func ==(lhs: Interaction_disableArticleSwipe_args, rhs: Interaction_disableArticleSwipe_args) -> Bool {
  return
    (lhs.disableSwipe == rhs.disableSwipe)
}

extension Interaction_disableArticleSwipe_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(disableSwipe)
  }

}

extension Interaction_disableArticleSwipe_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["disableSwipe": 1, ]
  }

  fileprivate static var structName: String { return "Interaction_disableArticleSwipe_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Interaction_disableArticleSwipe_args {
    _ = try proto.readStructBegin()
    var disableSwipe: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            disableSwipe = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(disableSwipe, named: "disableSwipe")

    return Interaction_disableArticleSwipe_args(disableSwipe: disableSwipe)
  }

}



fileprivate final class Interaction_disableArticleSwipe_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Interaction_disableArticleSwipe_result, rhs: Interaction_disableArticleSwipe_result) -> Bool {
  return true
}

extension Interaction_disableArticleSwipe_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Interaction_disableArticleSwipe_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Interaction_disableArticleSwipe_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Interaction_disableArticleSwipe_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Interaction_disableArticleSwipe_result()
  }

}



extension InteractionClient : Interaction {

  private func send_disableArticleSwipe(disableSwipe: Bool) throws {
    try outProtocol.writeMessageBegin(name: "disableArticleSwipe", type: .call, sequenceID: 0)
    let args = Interaction_disableArticleSwipe_args(disableSwipe: disableSwipe)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_disableArticleSwipe() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Interaction_disableArticleSwipe_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func disableArticleSwipe(disableSwipe: Bool) throws {
    try send_disableArticleSwipe(disableSwipe: disableSwipe)
    try outProtocol.transport.flush()
    try recv_disableArticleSwipe()
  }

}

extension InteractionProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["disableArticleSwipe"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Interaction_disableArticleSwipe_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Interaction_disableArticleSwipe_result()
      do {
        try handler.disableArticleSwipe(disableSwipe: args.disableSwipe)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "disableArticleSwipe", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
      try outProtocol.transport.flush()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = InteractionProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        try outProtocol.transport.flush()
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      try outProtocol.transport.flush()
    }
  }
}

extension InteractionProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["disableArticleSwipe"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Interaction_disableArticleSwipe_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.disableArticleSwipe(disableSwipe: args.disableSwipe, completion: { asyncResult in
        var result = Interaction_disableArticleSwipe_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "disableArticleSwipe", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "disableArticleSwipe", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "disableArticleSwipe", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = InteractionProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

